<style>
#box {
	width: 100vw;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
}

#container {
	box-shadow: inset 0px 0px 15px white;
	width: 385px;
    height: 400px;
    border-radius: 30px;
    background-color: #e0e0e0;
}

#display {
	width: 140px;
    height: 40px;
	background-color: white;
	position: absolute;
	transform: translate(15px, 15px);
	padding: 15px;
	font-size: 35px;
    border-radius: 7.5px;
    border-top-left-radius: 15px;
	box-shadow: 0px 0px 15px white;
}

#input {
	width: 270px;
	height: 70px;
	position: absolute;
	transform: matrix(1,0,0,1,15,100);
	font-size: 35px;
    border: 0;
    border-radius: 7.5px;
	box-shadow: 0px 0px 15px white;
}

#stats {
	width: 140px;
	height: 135px;
	background-color: white;
	transform: matrix(1,0,0,1,15,220);
	padding: 15px;
	font-size: 30px;
	line-height: 45px;
    border-radius: 7.5px;
    border-bottom-left-radius: 15px;
	box-shadow: 0px 0px 15px white;
}

#type {
	width: 170px;
    height: 70px;
    transform: matrix(1,0,0,1,200,-150);
    border-radius: 7.5px;
    border-top-right-radius: 15px;
	box-shadow: 0px 0px 15px white;
    font-size: 18px;
}

#reset {
	width: 170px;
    height: 40px;
    transform: matrix(1,0,0,1,25,165);
    border-radius: 5px;
    border-bottom-right-radius: 15px;
	box-shadow: 0px 0px 15px white;
    font-size: 16px;
}

#settings {
	width: 140px;
    height: 80px;
	box-shadow: 0px 0px 15px white;
    background-color: white;
    transform: translate(200px, -15px);
    border-radius: 5px;
	padding: 15px;
	font-size: 16px;
    line-height: 20px;
}

button {
    border: 0px;
    background-color: #d0d0d0;
}

#timer {
	width: 355px;
	height: 20px;
	background-color: transparent;
	position: absolute;
	transform: matrix(1,0,0,1,15,185);
}

progress[value]::-webkit-progress-bar {
	background-color: white;
    border-radius: 7.5px;
	box-shadow: 0px 0px 15px white;
}

progress[value]::-webkit-progress-value {
	background-color: green;
    border-radius: 7.5px;
}

#indicator {
	width: 70px;
	height: 70px;
	position: absolute;
	transform: matrix(1,0,0,1,300,100);
    border-radius: 7.5px;
	box-shadow: 0px 0px 15px white;
	animation-duration: 0.5s;
    animation-timing-function: ease;
}

.wrong {
	animation-name: wrong;
}

.right {
	animation-name: right;
}

@keyframes wrong {
	0% {background-color: red;}
	100% {background-color: white;}
}

@keyframes right {
	0% {background-color: green;}
	100% {background-color: white;}
}

input:not(#input) {
	width: 140px;
    height: 20px;
    font-size: 18px;
}
</style>

<div id="box">
	<div id="container">
		<div class="read" id="display"></div>
	    <input  type="number" id="input" autocomplete=off>
    	<div class="" id="indicator"></div>
	    <progress id="timer" value="0" max="100"></progress>
	    <div class="read" id="stats"></div>
	    <button id="type"></button>
        <button id="reset">Reset Timer + Stats</button>
        <div id="settings">Minimum Summand:<br><input id="min" value="1" type="number" autocomplete="off"><br>Maximum Summand:<br><input id="max" value="9" type="number" autocomplete="off"></div>
	</div>
</div>

<script>
var p = {
    type: "add",
    displayType() {switch(this.type) { case "mult":return "Multiplication";case "add":return "Addition"; }},
	problem: {},
    right: 0,
    wrong: 0,
    max: 9,
    min: 1,
    time: 1200,
    timeMax: 1200,
    step: 20,
    displayTime() { return Math.ceil(this.time/this.step) },
    running: false,
    anim: 0,
}

function Problem(type, part1, answer, part2 = undefined) {
	switch(type) {
    	case "mult":
        	this.answer = answer;
            this.part1 = part1;
            this.part2 = (part2 === undefined) ? answer/part1:part2;
            this.type = type;
            this.op = "*";
        	break;
    	case "add":
        	this.answer = answer;
            this.part1 = part1;
            this.part2 = (part2 === undefined) ? answer-part1:part2;
            this.type = type;
            this.op = "+";
        	break;
    }
    this.check = function(input) {
    	if(this.answer == input) return true;
        return false;
    };
}

function multProblem(max, min) {
	let list = [];
    let values = [];
    let factor, product, problem;
	for(var i = min; i <= max; i++) {
    	for(var o = min; o <= max; o++) {
        	if(values.includes(i*o) && list[values.indexOf(i*o)].product === i*o) {
            	list[values.indexOf(i*o)].factorpairs.push([i,o]);
                continue;
            }
        	values.push(i*o);
        	list.push({product: i*o, factorpairs: [[i,o]]})
        }
    }
    problem = list[Math.floor(Math.random()*list.length)];
    product = problem.product;
    factor = problem.factorpairs[Math.floor(Math.random()*problem.factorpairs.length)][(Math.random() > 0.5)?0:1];
	return new Problem("mult", factor, product);
}

function addProblem(max, min) {
	let sum = Math.max(2,2*min)+Math.floor(Math.random()*(max*2+1-Math.max(2,2*min)));
    let summand = Math.max(min, sum-max) + Math.floor(Math.random() * Math.min(sum-(2*min), 0-sum+(2*max)));
	return new Problem("add", summand, sum);
}

function newProblem(type, max, min) {
	switch(type) {
    	case "mult":
        	return multProblem(max, min);
        	break;
    	case "add":
        	return addProblem(max, min);
        	break;
    }
}

function tick() {
    if(p.running) {
    	p.time -= 1;
    	max.disabled = "true";
    	min.disabled = "true";
        type.disabled = "true";
    }
    if(p.time <= 0) {
    	input.disabled = "true";
        input.value = "";
        indicator.style.backgroundColor = "white";
        p.running = false;
    }
    if(p.max !== max.value) {p.max = max.value;generate(p.type, p.max, p.min)}
    if(p.min !== min.value) {p.min = min.value;generate(p.type, p.max, p.min)}
	timer.value = p.time/p.timeMax*100;
    type.innerHTML = "Type: " + p.displayType();
    stats.innerHTML = `
    	Right: ${p.right}<br>
    	Wrong: ${p.wrong}<br>
        Timer: ${p.displayTime()}
    `;
    display.innerHTML = p.problem.part1 + " " + p.problem.op + " " + p.problem.part2 + " = ?";
}

document.onkeypress = function (e) {
    e = e || window.event;
	if(e.key === "Enter" && input.value !== "") {
    	correct(p.problem, input);
    	generate(p.type, p.max, p.min);
        if(!p.running) p.running = true;
    }
};

function correct(correcting, correctFrom) {
	if(correcting.check(correctFrom.value)) {
    	p.right++;
        indicator.classList.add("right");
        p.anim = setTimeout(function(){
        	indicator.classList.remove("right");
        }, 500);
    } else {
    	p.wrong++;
        indicator.classList.add("wrong");
        p.anim = setTimeout(function(){
        	indicator.classList.remove("wrong");
        }, 500);
    }
}

function generate(type, max, min) {
    p.problem = newProblem(type, max, min);
    input.value = "";
}

function restart() {
	generate(p.type, p.max, p.min);
    p.time = p.timeMax;
    p.right = 0;
    p.wrong = 0;
    p.running = false;
    input.removeAttribute("disabled");
    max.removeAttribute("disabled");
    min.removeAttribute("disabled");
    type.removeAttribute("disabled");
    indicator.style.backgroundColor = "white";
}

function changeType() {
	switch(p.type) {
    	case "add":
        	p.type = "mult";
            break;
    	case "mult":
            p.type = "add";
            break;
    }
    generate(p.type, p.max, p.min);
}

var container = document.getElementById("container");
var display = document.getElementById("display");
var input = document.getElementById("input");
var indicator = document.getElementById("indicator");
var timer = document.getElementById("timer");
var stats = document.getElementById("stats");
var max = document.getElementById("max");
var min = document.getElementById("min");
var type = document.getElementById("type");
type.onmousedown = changeType;
var reset = document.getElementById("reset");
reset.onmousedown = restart;

generate(p.type, p.max, p.min);
indicator.style.backgroundColor = "white";
tick();
setInterval(tick, 1000/p.step);
</script>
